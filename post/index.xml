<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Codetector :: Yaotian Feng</title>
    <link>https://codetector.org/post/</link>
    <description>Recent content in Posts on Codetector :: Yaotian Feng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Dec 2020 00:00:00 -0400</lastBuildDate><atom:link href="https://codetector.org/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Keyboard Hacking - TEX Yoda II (1) HW Analysis</title>
      <link>https://codetector.org/post/tex_yoda/tex_yoda_part1/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 -0400</pubDate>
      
      <guid>https://codetector.org/post/tex_yoda/tex_yoda_part1/</guid>
      <description>Recently someone on reddit sent me a TEX Yoda II keyboard. It is certainly an interesting board. Not only it is a 60% which greatly saves desk space, it also integrates a IBM style &amp;ldquo;trackpoint&amp;rdquo; so you can put away your mouse too.
Unfortunately the firmware that came with the board is really boring and lack some features that I think is really needed to make a 60% keyboard work. Such as having layers that can be put into a lock mode, or having my typical caps becomes ESC and also act as a layer trigger so I can have arrow keys overlay onto the h j k l keys.</description>
    </item>
    
    <item>
      <title>Hakutaku: SMP on x86-64</title>
      <link>https://codetector.org/post/hakutaku/smp/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 -0400</pubDate>
      
      <guid>https://codetector.org/post/hakutaku/smp/</guid>
      <description>This is one post in my blog series about developing an Operating System for the x86-64 platform in Rust. I aim to cover a small topic in each post along with some code samples to get you started if you are also interested in doing such a project. The complete project is on Github
Multi-core Multi-core often sounds like a scary topic for most hobbyist OS developers. Today we will tackle this problem together in our Rust OS, Hakutaku.</description>
    </item>
    
    <item>
      <title>ASRock RGB Driver VR</title>
      <link>https://codetector.org/post/asrock_rgb_driver/</link>
      <pubDate>Sat, 20 Jun 2020 00:00:00 -0400</pubDate>
      
      <guid>https://codetector.org/post/asrock_rgb_driver/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>IntelliJ Plugin for TableGen</title>
      <link>https://codetector.org/post/intellij_tablegen_plugin/</link>
      <pubDate>Sun, 22 Dec 2019 00:46:18 +0800</pubDate>
      
      <guid>https://codetector.org/post/intellij_tablegen_plugin/</guid>
      <description>I recently been working on creating a LLVM backend for the Z80 CPU architechture. (A blog series to come) In the process of describing the architechture, LLVM use a DSL called TableGen Target Description Language to describe the target architechture. Everything from registers, instructions to calling conventions are first described in this TableGen format. Although there are existing plugins for VSCode, Vim, and Emacs, my main IDE for working on the project is CLion.</description>
    </item>
    
  </channel>
</rss>
